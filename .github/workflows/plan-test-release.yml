name: Plan-Test-Release

on:
  push:
  pull_request:
    branches: [ main, master ]

env:
  TF_CLOUD_TOKEN: ${{ secrets.TF_CLOUD_TOKEN }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  TEMPLATES_VERSION: v0.0.1  # Update this to use latest iac-pipeline-templates release

jobs:
  commit-check:
    name: Check Commit Message
    runs-on: ubuntu-latest
    outputs:
      should-run: ${{ steps.check.outputs.should-run }}
      should-create-pr: ${{ steps.check.outputs.should-create-pr }}
      should-release: ${{ steps.check.outputs.should-release }}
      target-provider: ${{ steps.check.outputs.target-provider }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check commit message
        id: check
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "Commit message: $COMMIT_MSG"
          
          # Check if this is GitHub Actions pipeline
          if [[ "$COMMIT_MSG" == *"[gh]"* ]]; then
            echo "✓ Pipeline should run for GitHub Actions"
            echo "should-run=true" >> $GITHUB_OUTPUT
            
            # Determine target provider
            if [[ "$COMMIT_MSG" == *"[azure]"* ]]; then
              echo "target-provider=azure" >> $GITHUB_OUTPUT
            elif [[ "$COMMIT_MSG" == *"[amazon]"* ]]; then
              echo "target-provider=aws" >> $GITHUB_OUTPUT
            elif [[ "$COMMIT_MSG" == *"[civo]"* ]]; then
              echo "target-provider=civo" >> $GITHUB_OUTPUT
            elif [[ "$COMMIT_MSG" == *"[oci]"* ]]; then
              echo "target-provider=oci" >> $GITHUB_OUTPUT
            else
              echo "target-provider=all" >> $GITHUB_OUTPUT
            fi
          elif [[ "$COMMIT_MSG" == *"[ado]"* ]] || [[ "$COMMIT_MSG" == *"[aws]"* ]] || [[ "$COMMIT_MSG" == *"[oci]"* ]]; then
            echo "✗ Pipeline should not run for GitHub Actions - commit message: $COMMIT_MSG"
            echo "should-run=false" >> $GITHUB_OUTPUT
            echo "should-create-pr=false" >> $GITHUB_OUTPUT
            echo "should-release=false" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "✓ Pipeline should run for GitHub Actions (default - no platform prefix)"
            echo "should-run=true" >> $GITHUB_OUTPUT
            echo "target-provider=all" >> $GITHUB_OUTPUT
          fi
          
          # Set pipeline variables for conditional stages
          if [[ "$COMMIT_MSG" == *"[release]"* ]] && [[ "$GITHUB_REF" != "refs/heads/main" ]] && [[ "$GITHUB_REF" != "refs/heads/master" ]]; then
            echo "should-create-pr=true" >> $GITHUB_OUTPUT
            echo "should-release=false" >> $GITHUB_OUTPUT
          elif [[ "$GITHUB_REF" == "refs/heads/main" ]] || [[ "$GITHUB_REF" == "refs/heads/master" ]]; then
            echo "should-create-pr=false" >> $GITHUB_OUTPUT
            echo "should-release=true" >> $GITHUB_OUTPUT
          else
            echo "should-create-pr=false" >> $GITHUB_OUTPUT
            echo "should-release=false" >> $GITHUB_OUTPUT
          fi

  plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: commit-check
    if: needs.commit-check.outputs.should-run == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Configure Terraform Cloud authentication
        run: |
          mkdir -p ~/.terraform.d
          echo "credentials \"app.terraform.io\" { token = \"$TF_CLOUD_TOKEN\" }" > ~/.terraform.d/credentials.tfrc.json

      - name: Test module consumption patterns
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)
          TARGET_PROVIDER="${{ needs.commit-check.outputs.target-provider }}"
          echo "Target provider: $TARGET_PROVIDER"
          
          if [[ "$TARGET_PROVIDER" == "azure" ]]; then
            echo "Testing Azure module consumption..."
            cd examples/azure-example
            terraform init
            terraform plan
          elif [[ "$TARGET_PROVIDER" == "aws" ]]; then
            echo "Testing AWS module consumption..."
            cd examples/aws-example
            terraform init
            terraform plan
          elif [[ "$TARGET_PROVIDER" == "civo" ]]; then
            echo "Testing Civo module consumption..."
            if [ -d "examples/civo-example" ]; then
              cd examples/civo-example
              terraform init
              terraform plan
            else
              echo "Civo example not found, validating module only"
            fi
          elif [[ "$TARGET_PROVIDER" == "oci" ]]; then
            echo "Testing OCI module consumption..."
            if [ -d "examples/oci-example" ]; then
              cd examples/oci-example
              terraform init
              terraform plan
            else
              echo "OCI example not found, validating module only"
            fi
          else
            echo "Testing all module consumption patterns..."
            cd examples/aws-example
            terraform init
            terraform plan
            cd ../azure-example
            terraform init
            terraform plan
          fi
          echo "✓ Plan stage completed successfully"

  test:
    name: Security and Linting
    runs-on: ubuntu-latest
    needs: commit-check
    if: needs.commit-check.outputs.should-run == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.8'

      - name: Install security scanning tools
        run: |
          pip install checkov

      - name: Run security scanning and linting
        run: |
          TARGET_PROVIDER="${{ needs.commit-check.outputs.target-provider }}"
          echo "Target provider: $TARGET_PROVIDER"
          
          if [[ "$TARGET_PROVIDER" == "azure" ]]; then
            echo "Scanning Azure module only..."
            cd iac/terraform/azure
            terraform fmt -check
            terraform validate
            checkov -f . --framework terraform --quiet
          elif [[ "$TARGET_PROVIDER" == "aws" ]]; then
            echo "Scanning AWS module only..."
            cd iac/terraform/aws
            terraform fmt -check
            terraform validate
            checkov -f . --framework terraform --quiet
          elif [[ "$TARGET_PROVIDER" == "civo" ]]; then
            echo "Scanning Civo module only..."
            cd iac/terraform/civo
            terraform fmt -check
            terraform validate
            checkov -f . --framework terraform --quiet
          elif [[ "$TARGET_PROVIDER" == "oci" ]]; then
            echo "Scanning OCI module only..."
            cd iac/terraform/oci
            terraform fmt -check
            terraform validate
            checkov -f . --framework terraform --quiet
          else
            echo "Scanning all modules..."
            for provider in aws azure civo oci; do
              if [ -d "iac/terraform/$provider" ]; then
                echo "Scanning $provider module..."
                cd "iac/terraform/$provider"
                terraform fmt -check
                terraform validate
                checkov -f . --framework terraform --quiet
                cd ../../..
              fi
            done
          fi
          echo "✓ All security and linting tests passed"

  create-pr:
    name: Create Pull Request
    runs-on: ubuntu-latest
    needs: [commit-check, plan, test]
    if: needs.commit-check.outputs.should-create-pr == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create pull request
        run: |
          echo "Creating pull request..."
          
          # Configure git
          git config --global user.email "pipeline@company.com"
          git config --global user.name "GitHub Actions"
          
          # Get current branch name
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          echo "Current branch: $CURRENT_BRANCH"
          
          # Determine target branch
          if git show-ref --verify --quiet refs/remotes/origin/main; then
            TARGET_BRANCH="main"
          else
            TARGET_BRANCH="master"
          fi
          echo "Target branch: $TARGET_BRANCH"
          
          # Create PR
          COMMIT_MSG=$(git log -1 --pretty=%B)
          PR_TITLE="Release: $(echo "$COMMIT_MSG" | head -n1 | sed 's/\[.*\]//g' | xargs)"
          
          gh pr create \
            --title "$PR_TITLE" \
            --body "Automated PR created by GitHub Actions

          Commit: $COMMIT_MSG

          Ready for review and release approval." \
            --base "$TARGET_BRANCH" \
            --head "$CURRENT_BRANCH"
          
          echo "✓ Pull request created successfully"

  release:
    name: Publish Modules
    runs-on: ubuntu-latest
    needs: [commit-check, plan, test]
    if: needs.commit-check.outputs.should-release == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Publish modules to Terraform Cloud
        run: |
          echo "Publishing modules to Terraform Cloud..."
          
          # Configure git with GitHub token for authentication
          git config --global user.email "pipeline@company.com"
          git config --global user.name "GitHub Actions"
          git remote set-url origin https://$GITHUB_TOKEN@github.com/$GITHUB_REPOSITORY.git
          
          # Get the latest version from git tags
          echo "Fetching latest version from git tags..."
          git fetch --tags
          LATEST_TAG=$(git tag -l "v*" | sort -V | tail -n1)
          
          if [ -z "$LATEST_TAG" ]; then
            # No previous tags, start with 0.0.1
            CURRENT_MAJOR=0
            CURRENT_MINOR=0
            CURRENT_PATCH=1
            echo "No previous tags found, starting with 0.0.1"
          else
            # Parse current version
            CURRENT_VERSION=${LATEST_TAG#v}
            CURRENT_MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
            CURRENT_MINOR=$(echo $CURRENT_VERSION | cut -d. -f2)
            CURRENT_PATCH=$(echo $CURRENT_VERSION | cut -d. -f3)
            echo "Current version: $CURRENT_VERSION (Major: $CURRENT_MAJOR, Minor: $CURRENT_MINOR, Patch: $CURRENT_PATCH)"
          fi
          
          # Get PR approval message to determine version bump
          echo "Checking PR approval message for version bump type..."
          
          # Get the merge commit message which contains PR info
          MERGE_COMMIT_MSG="$(git log -1 --pretty=%B)"
          echo "Merge commit message: $MERGE_COMMIT_MSG"
          
          # Determine version bump based on approval message
          if echo "$MERGE_COMMIT_MSG" | grep -i "APPROVED MAJOR" > /dev/null; then
            NEW_MAJOR=$((CURRENT_MAJOR + 1))
            NEW_MINOR=0
            NEW_PATCH=0
            BUMP_TYPE="MAJOR"
          elif echo "$MERGE_COMMIT_MSG" | grep -i "APPROVED MINOR" > /dev/null; then
            NEW_MAJOR=$CURRENT_MAJOR
            NEW_MINOR=$((CURRENT_MINOR + 1))
            NEW_PATCH=0
            BUMP_TYPE="MINOR"
          else
            # Default to PATCH if no specific approval message or "APPROVED PATCH"
            NEW_MAJOR=$CURRENT_MAJOR
            NEW_MINOR=$CURRENT_MINOR
            NEW_PATCH=$((CURRENT_PATCH + 1))
            BUMP_TYPE="PATCH"
          fi
          
          VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          echo "Version bump type: $BUMP_TYPE"
          echo "Publishing version: $VERSION"
          
          # Create git tag for this version
          git tag -a "v$VERSION" -m "Automated release v$VERSION"
          git push origin "v$VERSION"
          
          echo "✓ Modules published with version: v$VERSION"