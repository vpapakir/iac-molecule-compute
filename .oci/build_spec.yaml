version: 1.0
component: build
timeoutInSeconds: 3600
shell: bash

# Default to latest iac-pipeline-templates release
# Override by setting TEMPLATES_VERSION environment variable
env:
  variables:
    TEMPLATES_VERSION: "v0.0.1"

inputArtifacts:
  - name: source
    type: INLINE

steps:
  - type: Command
    name: "commitCheck"
    command: |
      COMMIT_MSG=$(git log -1 --pretty=%B)
      echo "Commit message: $COMMIT_MSG"
      
      # Check if this is OCI pipeline or default (no prefix)
      if [[ "$COMMIT_MSG" == *"[oci]"* ]] || [[ "$COMMIT_MSG" != *"[ado]"* && "$COMMIT_MSG" != *"[gh]"* && "$COMMIT_MSG" != *"[aws]"* ]]; then
        echo "✓ Pipeline should run for OCI DevOps"
        
        # Set pipeline variables for conditional stages
        if [[ "$COMMIT_MSG" == *"[release]"* ]] && [[ "$OCI_BUILD_SOURCE_BRANCH_NAME" != "main" ]] && [[ "$OCI_BUILD_SOURCE_BRANCH_NAME" != "master" ]]; then
          echo "SHOULD_CREATE_PR=true" >> $OCI_BUILD_RUN_ID.env
          echo "SHOULD_RELEASE=false" >> $OCI_BUILD_RUN_ID.env
        elif [[ "$OCI_BUILD_SOURCE_BRANCH_NAME" == "main" ]] || [[ "$OCI_BUILD_SOURCE_BRANCH_NAME" == "master" ]]; then
          echo "SHOULD_CREATE_PR=false" >> $OCI_BUILD_RUN_ID.env
          echo "SHOULD_RELEASE=true" >> $OCI_BUILD_RUN_ID.env
        else
          echo "SHOULD_CREATE_PR=false" >> $OCI_BUILD_RUN_ID.env
          echo "SHOULD_RELEASE=false" >> $OCI_BUILD_RUN_ID.env
        fi
      else
        echo "✗ Pipeline should not run for OCI DevOps - commit message: $COMMIT_MSG"
        exit 1
      fi

  - type: Command
    name: "setupTerraform"
    command: |
      echo "Installing Terraform..."
      wget https://releases.hashicorp.com/terraform/1.6.0/terraform_1.6.0_linux_amd64.zip
      unzip terraform_1.6.0_linux_amd64.zip
      sudo mv terraform /usr/local/bin/
      terraform --version

  - type: Command
    name: "plan"
    command: |
      echo "Configuring Terraform Cloud authentication..."
      mkdir -p ~/.terraform.d
      echo "credentials \"app.terraform.io\" { token = \"$TF_CLOUD_TOKEN\" }" > ~/.terraform.d/credentials.tfrc.json
      
      echo "Testing module consumption patterns..."
      cd examples/aws-example
      terraform init
      terraform plan
      cd ../azure-example  
      terraform init
      terraform plan
      echo "✓ Plan stage completed successfully"

  - type: Command
    name: "test"
    command: |
      echo "Installing security scanning tools..."
      pip3 install checkov
      
      echo "Running security scanning and linting..."
      cd iac/terraform/aws
      terraform fmt -check
      terraform validate
      checkov -f . --framework terraform --quiet
      cd ../azure
      terraform fmt -check  
      terraform validate
      checkov -f . --framework terraform --quiet
      cd ../civo
      terraform fmt -check
      terraform validate
      checkov -f . --framework terraform --quiet
      cd ../oci
      terraform fmt -check
      terraform validate
      checkov -f . --framework terraform --quiet
      echo "✓ All security and linting tests passed"

  - type: Command
    name: "createPR"
    condition: |
      [ -f "$OCI_BUILD_RUN_ID.env" ] && grep -q "SHOULD_CREATE_PR=true" "$OCI_BUILD_RUN_ID.env"
    command: |
      echo "Installing GitHub CLI..."
      curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | gpg --dearmor -o /usr/share/keyrings/githubcli-archive-keyring.gpg
      echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null
      apt update && apt install gh -y
      
      echo "Creating pull request..."
      
      # Configure git
      git config --global user.email "pipeline@company.com"
      git config --global user.name "OCI DevOps"
      
      # Authenticate with GitHub
      echo "$GITHUB_TOKEN" | gh auth login --with-token
      
      # Get current branch name
      CURRENT_BRANCH="$OCI_BUILD_SOURCE_BRANCH_NAME"
      echo "Current branch: $CURRENT_BRANCH"
      
      # Determine target branch
      if git show-ref --verify --quiet refs/remotes/origin/main; then
        TARGET_BRANCH="main"
      else
        TARGET_BRANCH="master"
      fi
      echo "Target branch: $TARGET_BRANCH"
      
      # Create PR
      COMMIT_MSG=$(git log -1 --pretty=%B)
      PR_TITLE="Release: $(echo "$COMMIT_MSG" | head -n1 | sed 's/\[.*\]//g' | xargs)"
      
      gh pr create \
        --title "$PR_TITLE" \
        --body "Automated PR created by OCI DevOps

      Commit: $COMMIT_MSG

      Ready for review and release approval." \
        --base "$TARGET_BRANCH" \
        --head "$CURRENT_BRANCH"
      
      echo "✓ Pull request created successfully"

  - type: Command
    name: "release"
    condition: |
      [ -f "$OCI_BUILD_RUN_ID.env" ] && grep -q "SHOULD_RELEASE=true" "$OCI_BUILD_RUN_ID.env"
    command: |
      echo "Publishing modules to Terraform Cloud..."
      
      # Configure git with GitHub token for authentication
      git config --global user.email "pipeline@company.com"
      git config --global user.name "OCI DevOps"
      git remote set-url origin https://$GITHUB_TOKEN@github.com/$OCI_BUILD_SOURCE_REPOSITORY_URL
      
      # Get the latest version from git tags
      echo "Fetching latest version from git tags..."
      git fetch --tags
      LATEST_TAG=$(git tag -l "v*" | sort -V | tail -n1)
      
      if [ -z "$LATEST_TAG" ]; then
        # No previous tags, start with 0.0.1
        CURRENT_MAJOR=0
        CURRENT_MINOR=0
        CURRENT_PATCH=1
        echo "No previous tags found, starting with 0.0.1"
      else
        # Parse current version
        CURRENT_VERSION=${LATEST_TAG#v}
        CURRENT_MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
        CURRENT_MINOR=$(echo $CURRENT_VERSION | cut -d. -f2)
        CURRENT_PATCH=$(echo $CURRENT_VERSION | cut -d. -f3)
        echo "Current version: $CURRENT_VERSION (Major: $CURRENT_MAJOR, Minor: $CURRENT_MINOR, Patch: $CURRENT_PATCH)"
      fi
      
      # Get PR approval message to determine version bump
      echo "Checking PR approval message for version bump type..."
      
      # Get the merge commit message which contains PR info
      MERGE_COMMIT_MSG="$(git log -1 --pretty=%B)"
      echo "Merge commit message: $MERGE_COMMIT_MSG"
      
      # Determine version bump based on approval message
      if echo "$MERGE_COMMIT_MSG" | grep -i "APPROVED MAJOR" > /dev/null; then
        NEW_MAJOR=$((CURRENT_MAJOR + 1))
        NEW_MINOR=0
        NEW_PATCH=0
        BUMP_TYPE="MAJOR"
      elif echo "$MERGE_COMMIT_MSG" | grep -i "APPROVED MINOR" > /dev/null; then
        NEW_MAJOR=$CURRENT_MAJOR
        NEW_MINOR=$((CURRENT_MINOR + 1))
        NEW_PATCH=0
        BUMP_TYPE="MINOR"
      else
        # Default to PATCH if no specific approval message or "APPROVED PATCH"
        NEW_MAJOR=$CURRENT_MAJOR
        NEW_MINOR=$CURRENT_MINOR
        NEW_PATCH=$((CURRENT_PATCH + 1))
        BUMP_TYPE="PATCH"
      fi
      
      VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
      echo "Version bump type: $BUMP_TYPE"
      echo "Publishing version: $VERSION"
      
      # Create git tag for this version
      git tag -a "v$VERSION" -m "Automated release v$VERSION"
      git push origin "v$VERSION"
      
      echo "✓ Modules published with version: v$VERSION"

outputArtifacts:
  - name: built_artifacts
    type: BINARY
    location: ./