trigger:
  branches:
    include:
      - '*'

pool:
  vmImage: 'ubuntu-latest'

variables:
- group: terraform
- group: shared
- name: terraformVersion
  value: '1.6.0'

stages:
- stage: CommitCheck
  jobs:
  - job: ParseCommit
    steps:
    - bash: |
        COMMIT_MSG="$(Build.SourceVersionMessage)"
        echo "Commit message: $COMMIT_MSG"
        
        # Check if this pipeline should run
        if [[ "$COMMIT_MSG" != *"[ado]"* ]]; then
          echo "‚ùå Skipping - not Azure DevOps job"
          echo "##vso[task.complete result=Succeeded;]Pipeline skipped"
          exit 0
        fi
        
        echo "‚úÖ Azure DevOps should handle this"
        echo "##vso[task.setvariable variable=shouldRun;isOutput=true]true"
        
        # Determine cloud provider
        if [[ "$COMMIT_MSG" == *"[azure]"* ]]; then
          CLOUD_PROVIDER="azure"
        elif [[ "$COMMIT_MSG" == *"[aws]"* ]]; then
          CLOUD_PROVIDER="aws"
        elif [[ "$COMMIT_MSG" == *"[civo]"* ]]; then
          CLOUD_PROVIDER="civo"
        elif [[ "$COMMIT_MSG" == *"[oci]"* ]]; then
          CLOUD_PROVIDER="oci"
        else
          CLOUD_PROVIDER="azure"  # default
        fi
        
        echo "##vso[task.setvariable variable=cloudProvider;isOutput=true]$CLOUD_PROVIDER"
        
        # Determine action
        if [[ "$COMMIT_MSG" == *"[release]"* ]]; then
          echo "##vso[task.setvariable variable=isRelease;isOutput=true]true"
        else
          echo "##vso[task.setvariable variable=isRelease;isOutput=true]false"
        fi
      name: commitCheck
      displayName: 'Parse commit message'

- stage: Build
  condition: eq(dependencies.CommitCheck.outputs['ParseCommit.commitCheck.shouldRun'], 'true')
  dependsOn: CommitCheck
  variables:
    cloudProvider: $[ dependencies.CommitCheck.outputs['ParseCommit.commitCheck.cloudProvider'] ]
  jobs:
  - job: Validate
    steps:
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: $(terraformVersion)
    
    - bash: |
        # Configure Terraform Cloud
        mkdir -p ~/.terraform.d
        echo "credentials \"app.terraform.io\" { token = \"$(apiKey)\" }" > ~/.terraform.d/credentials.tfrc.json
        
        CLOUD_PROVIDER="$(cloudProvider)"
        echo "Validating $CLOUD_PROVIDER module..."
        
        # Test example if exists
        if [ -d "examples/${CLOUD_PROVIDER}-example" ]; then
          echo "‚Üí Testing example: examples/${CLOUD_PROVIDER}-example"
          cd "examples/${CLOUD_PROVIDER}-example"
          
          echo "Running terraform init..."
          terraform init
          
          echo "Running terraform plan..."
          terraform plan
          
          echo "Running terraform validate..."
          terraform validate
          
          cd ../..
          echo "‚úÖ Example validation completed"
        else
          echo "‚ö†Ô∏è No example found for $CLOUD_PROVIDER"
        fi
        
        # Test module
        if [ -d "iac/terraform/${CLOUD_PROVIDER}" ]; then
          echo "‚Üí Testing module: iac/terraform/${CLOUD_PROVIDER}"
          cd "iac/terraform/${CLOUD_PROVIDER}"
          
          echo "Running terraform init..."
          terraform init
          
          echo "Running terraform fmt -check..."
          terraform fmt -check
          
          echo "Running terraform validate..."
          terraform validate
          
          echo "Installing Checkov..."
          pip3 install checkov
          
          echo "Running Checkov security scan..."
          checkov -d . --framework terraform
          
          cd ../../..
          echo "‚úÖ Module validation completed"
        else
          echo "‚ö†Ô∏è No module found for $CLOUD_PROVIDER"
        fi
      displayName: 'Validate Terraform'

- stage: CreatePR
  condition: and(succeeded(), eq(dependencies.CommitCheck.outputs['ParseCommit.commitCheck.isRelease'], 'true'), ne(variables['Build.SourceBranch'], 'refs/heads/main'))
  dependsOn: [CommitCheck, Build]
  variables:
    cloudProvider: $[ dependencies.CommitCheck.outputs['ParseCommit.commitCheck.cloudProvider'] ]
  jobs:
  - job: CreatePullRequest
    steps:
    - bash: |
        CLOUD_PROVIDER="$(cloudProvider)"
        BRANCH_NAME=$(echo "$(Build.SourceBranch)" | sed 's|refs/heads/||')
        
        # Create PR using GitHub CLI
        echo "$(GITHUB_TOKEN)" | gh auth login --with-token
        
        gh pr create \
          --title "Release: ${CLOUD_PROVIDER} module updates" \
          --body "Automated release PR

        Approve with: [APPROVED] [PATCH] [ado]" \
          --base main \
          --head "$BRANCH_NAME"
        
        echo "‚úÖ Release PR created"
      displayName: 'Create Release PR'
      env:
        GITHUB_TOKEN: $(GITHUB_TOKEN)

- stage: Publish
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  dependsOn: CommitCheck
  jobs:
  - job: PublishModule
    steps:
    - bash: |
        # Get PR merge commit message
        MERGE_MSG="$(Build.SourceVersionMessage)"
        echo "Merge message: $MERGE_MSG"
        
        # Check if this tool should publish
        if [[ "$MERGE_MSG" != *"[ado]"* ]]; then
          echo "‚ùå Skipping publish - not approved for Azure DevOps"
          exit 0
        fi
        
        echo "‚úÖ Publishing module..."
        
        # Determine version bump
        if [[ "$MERGE_MSG" == *"[MAJOR]"* ]]; then
          BUMP_TYPE="major"
        elif [[ "$MERGE_MSG" == *"[MINOR]"* ]]; then
          BUMP_TYPE="minor"
        else
          BUMP_TYPE="patch"
        fi
        
        # Get current version and bump
        git fetch --tags
        LATEST_TAG=$(git tag -l "v*" | sort -V | tail -n1)
        
        if [ -z "$LATEST_TAG" ]; then
          NEW_VERSION="0.0.1"
        else
          CURRENT_VERSION=${LATEST_TAG#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          case $BUMP_TYPE in
            major) NEW_VERSION="$((MAJOR + 1)).0.0" ;;
            minor) NEW_VERSION="$MAJOR.$((MINOR + 1)).0" ;;
            patch) NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))" ;;
          esac
        fi
        
        # Configure git
        git config --global user.email "pipeline@company.com"
        git config --global user.name "Azure DevOps"
        
        # Create and push tag
        git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
        git remote set-url origin https://$(GITHUB_TOKEN)@github.com/vpapakir/iac-molecule-compute.git
        git push origin "v$NEW_VERSION"
        
        echo "üöÄ Published version: v$NEW_VERSION"
      displayName: 'Publish Module'
      env:
        GITHUB_TOKEN: $(GITHUB_TOKEN)