# AWS CodePipeline buildspec.yml
# This file references the centralized template from iac-pipeline-templates
# Template: https://github.com/vpapakir/iac-pipeline-templates/blob/main/aws-codepipeline/buildspec.yml
# Version: v0.0.5

# To use the centralized template:
# 1. Copy the template content from the URL above
# 2. Or use a script to download it during pipeline setup
# 3. This ensures consistency across all infrastructure repositories

# For now, using local copy until template repository is tagged
version: 0.2

phases:
  install:
    commands:
      - echo "Installing Terraform and tools..."
      - wget https://releases.hashicorp.com/terraform/1.6.0/terraform_1.6.0_linux_amd64.zip
      - unzip terraform_1.6.0_linux_amd64.zip
      - mv terraform /usr/local/bin/
      - terraform --version
      - pip3 install checkov
      
  pre_build:
    commands:
      - echo "Starting AWS CodePipeline build..."
      - echo "Commit message - $CODEBUILD_SOURCE_VERSION"
      - echo "Branch - $CODEBUILD_WEBHOOK_HEAD_REF"
      
  build:
    commands:
      - |
        # Get commit message from CodePipeline environment or git
        if [ -n "$CODEBUILD_SOURCE_VERSION" ] && [[ "$CODEBUILD_SOURCE_VERSION" == *"arn:aws:s3"* ]]; then
          # CodePipeline source - commit message not available, use default behavior
          COMMIT_MSG=""
          echo "=== COMMIT MESSAGE DEBUG ==="
          echo "CodePipeline source detected - no commit message available"
          echo "Using default pipeline behavior (scan all modules)"
          echo "=============================="
        else
          # Direct git source or webhook
          COMMIT_MSG=$(git log -1 --pretty=%B 2>/dev/null | tr -d '\0' || echo "")
          # Clean up commit message
          COMMIT_MSG=$(echo "$COMMIT_MSG" | head -1 | tr -d '\n\r')
          echo "=== COMMIT MESSAGE DEBUG ==="
          echo "Raw commit message: '$COMMIT_MSG'"
          echo "Commit message length: ${#COMMIT_MSG}"
          echo "Contains [aws]: $(echo "$COMMIT_MSG" | grep -c '\[aws\]' || echo '0')"
          echo "=============================="
        fi
        
        # Check if this is AWS pipeline or default (no prefix)
        if [[ "$COMMIT_MSG" == *"[aws]"* ]] || [[ "$COMMIT_MSG" != *"[ado]"* && "$COMMIT_MSG" != *"[gh]"* && "$COMMIT_MSG" != *"[oci]"* ]]; then
          echo "✓ Pipeline should run for AWS CodePipeline"
          echo "DEBUG: Commit message contains [aws]: $(echo "$COMMIT_MSG" | grep -o '\[aws\]' || echo 'NO')"
          echo "DEBUG: Commit message does not contain [ado]: $(echo "$COMMIT_MSG" | grep -o '\[ado\]' && echo 'NO' || echo 'YES')"
          echo "DEBUG: Commit message does not contain [gh]: $(echo "$COMMIT_MSG" | grep -o '\[gh\]' && echo 'NO' || echo 'YES')"
          echo "DEBUG: Commit message does not contain [oci]: $(echo "$COMMIT_MSG" | grep -o '\[oci\]' && echo 'NO' || echo 'YES')"
          
          # Configure Terraform Cloud
          echo "Configuring Terraform Cloud authentication..."
          mkdir -p ~/.terraform.d
          echo "credentials \"app.terraform.io\" { token = \"$TF_CLOUD_TOKEN\" }" > ~/.terraform.d/credentials.tfrc.json
          
          # PLAN STAGE - Test module consumption
          echo "→ Running Plan stage..."
          if [[ "$COMMIT_MSG" == *"[aws]"* ]]; then
            # AWS-specific pipeline - only test AWS example
            if [ -d "examples/aws-example" ]; then
              cd examples/aws-example
              terraform init
              echo "--- AWS Example Plan ---"
              terraform plan
              echo "--- AWS Example Validation ---"
              terraform validate
              cd ../..
            fi
          else
            # Default pipeline - test all examples
            if [ -d "examples/aws-example" ]; then
              cd examples/aws-example
              terraform init
              echo "--- AWS Example Plan ---"
              terraform plan
              echo "--- AWS Example Validation ---"
              terraform validate
              cd ../..
            fi
            
            if [ -d "examples/azure-example" ]; then
              cd examples/azure-example
              terraform init
              echo "--- Azure Example Validation ---"
              terraform validate
              cd ../..
            fi
          fi
          
          # TEST STAGE - Security scanning and linting
          echo "→ Running Test stage..."
          
          # Determine which modules to scan based on commit message
          if [[ "$COMMIT_MSG" == *"[aws]"* ]]; then
            # AWS-specific pipeline - only scan AWS module
            echo "DEBUG: Taking AWS-specific path because commit contains [aws]"
            echo "Scanning AWS module only (AWS-specific pipeline)..."
            if [ -d "iac/terraform/aws" ]; then
              cd iac/terraform/aws
              terraform init
              terraform fmt -check
              terraform validate
              checkov -d . --framework terraform
              CHECKOV_EXIT_CODE=$?
              if [ $CHECKOV_EXIT_CODE -ne 0 ]; then
                echo "⚠️ Security scan found issues in AWS module"
                exit 1
              fi
              cd ../../..
              echo "✓ AWS module validation completed"
            else
              echo "⚠️ AWS module directory not found"
              exit 1
            fi
          else
            # Default pipeline - scan all modules
            echo "DEBUG: Taking default path because commit does NOT contain [aws]"
            echo "Scanning all modules (default pipeline)..."
            for provider in aws azure civo oci; do
              if [ -d "iac/terraform/$provider" ]; then
                echo "Scanning $provider module..."
                cd "iac/terraform/$provider"
                terraform init
                terraform fmt -check
                terraform validate
                if [ "$provider" = "aws" ]; then
                  checkov -d . --framework terraform
                  CHECKOV_EXIT_CODE=$?
                  if [ $CHECKOV_EXIT_CODE -ne 0 ]; then
                    echo "⚠️ Security scan found issues in $provider module"
                    exit 1
                  fi
                fi
                cd ../../..
              fi
            done
          fi
          
          # CONDITIONAL STAGES - Force PR creation for testing
          echo "=== PR CREATION DEBUG ==="
          echo "Raw COMMIT_MSG: '$COMMIT_MSG'"
          echo "COMMIT_MSG length: ${#COMMIT_MSG}"
          echo "Forcing PR creation since commit message is empty (manual build)"
          echo "CODEBUILD_WEBHOOK_HEAD_REF: '$CODEBUILD_WEBHOOK_HEAD_REF'"
          
          # Fallback to actual git branch if webhook ref is not available
          CURRENT_BRANCH_REF="$CODEBUILD_WEBHOOK_HEAD_REF"
          if [ -z "$CURRENT_BRANCH_REF" ]; then
            ACTUAL_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || git symbolic-ref --short HEAD 2>/dev/null || echo "development")
            CURRENT_BRANCH_REF="refs/heads/$ACTUAL_BRANCH"
            echo "Using fallback branch: $CURRENT_BRANCH_REF"
          fi
          echo "Final branch ref: '$CURRENT_BRANCH_REF'"
          echo "============================="
          
          # Force PR creation if commit message is empty (manual build) and not on main
          if ([[ "$COMMIT_MSG" == *"[release]"* ]] || [[ -z "$COMMIT_MSG" ]]) && [[ "$CURRENT_BRANCH_REF" != "refs/heads/main" ]]; then
            echo "→ Creating PR (release flag + feature branch)"
            
            # Install GitHub CLI for Amazon Linux
            yum update -y
            yum install -y git
            curl -fsSL https://github.com/cli/cli/releases/download/v2.40.1/gh_2.40.1_linux_amd64.tar.gz -o gh.tar.gz
            tar -xzf gh.tar.gz
            mv gh_2.40.1_linux_amd64/bin/gh /usr/local/bin/
            
            # Ensure we're in the right directory and it's a git repo
            cd $CODEBUILD_SRC_DIR
            git config --global --add safe.directory $CODEBUILD_SRC_DIR
            
            # Configure git and create PR
            git config --global user.email "pipeline@company.com"
            git config --global user.name "AWS CodeBuild"
            echo "$GITHUB_TOKEN" | gh auth login --with-token
            
            # Create PR
            CURRENT_BRANCH="development"
            TARGET_BRANCH="main"
            PR_TITLE="Release: Civo module fixes and improvements"
            
            gh pr create \
              --title "$PR_TITLE" \
              --body "Automated PR created by AWS CodePipeline

            Branch: $CURRENT_BRANCH
            Manual build trigger

            Ready for review and release approval." \
              --base "$TARGET_BRANCH" \
              --head "$CURRENT_BRANCH"
            
            echo "✓ Pull request created successfully"
            
          elif [[ "$CURRENT_BRANCH_REF" == "refs/heads/main" ]]; then
            echo "→ Running Release stage (main branch)"
            
            # Configure git for tagging
            COMMIT_AUTHOR_EMAIL=$(git log -1 --pretty=format:'%ae')
            COMMIT_AUTHOR_NAME=$(git log -1 --pretty=format:'%an')
            git config --global user.email "${COMMIT_AUTHOR_EMAIL:-pipeline@company.com}"
            git config --global user.name "${COMMIT_AUTHOR_NAME:-AWS CodeBuild}"
            git remote set-url origin https://$GITHUB_TOKEN@github.com/$CODEBUILD_SOURCE_REPO_URL
            
            # Get latest version from git tags
            git fetch --tags
            LATEST_TAG=$(git tag -l "v*" | sort -V | tail -n1)
            
            if [ -z "$LATEST_TAG" ]; then
              CURRENT_MAJOR=0
              CURRENT_MINOR=0
              CURRENT_PATCH=1
            else
              CURRENT_VERSION=${LATEST_TAG#v}
              CURRENT_MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
              CURRENT_MINOR=$(echo $CURRENT_VERSION | cut -d. -f2)
              CURRENT_PATCH=$(echo $CURRENT_VERSION | cut -d. -f3)
            fi
            
            # Get PR approval message for version bump
            MERGE_COMMIT_MSG="$(git log -1 --pretty=%B)"
            
            if echo "$MERGE_COMMIT_MSG" | grep -i "APPROVED MAJOR" > /dev/null; then
              NEW_MAJOR=$((CURRENT_MAJOR + 1))
              NEW_MINOR=0
              NEW_PATCH=0
            elif echo "$MERGE_COMMIT_MSG" | grep -i "APPROVED MINOR" > /dev/null; then
              NEW_MAJOR=$CURRENT_MAJOR
              NEW_MINOR=$((CURRENT_MINOR + 1))
              NEW_PATCH=0
            else
              NEW_MAJOR=$CURRENT_MAJOR
              NEW_MINOR=$CURRENT_MINOR
              NEW_PATCH=$((CURRENT_PATCH + 1))
            fi
            
            VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
            echo "Publishing version: $VERSION"
            
            # Create git tag
            git tag -a "v$VERSION" -m "Automated release v$VERSION"
            git push origin "v$VERSION"
            
            echo "✓ Modules published with version: v$VERSION"
          fi
          
        else
          echo "ℹ Pipeline should not run for AWS - commit message: $COMMIT_MSG"
          exit 0
        fi
        
  post_build:
    commands:
      - echo "AWS CodePipeline build completed successfully!"

artifacts:
  files:
    - '**/*'